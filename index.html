<!DOCTYPE html>
<html lang="en">
<head>
	
	<!-- Custom Header Code For lumeral.fit -->
	<meta name="keywords" content="lumeral, Lumeral, photos, portraits, headshots">
	<meta name="description" content="Lumeral: Next-level portrait photography for personal and professional needs.">
	
	<link rel="canonical" href="https://www.lumeral.photo" />
	
	<!-- Open Graph / Facebook -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://www.lumeral.fit">
	<meta property="og:title" content="Lumeral: Professional Portrait Photography">
	<meta property="og:description" content="Lumeral: Next-level portrait photography for personal and professional needs.">
	<meta property="og:image" content="https://www.lumeral.fit/logo.png">
	<meta property="og:site_name" content="Lumeral">
	<meta property="og:image:width" content="1200">
	<meta property="og:image:height" content="630">
	<meta property="og:locale" content="en_US"> 
	
	<!-- Twitter -->
	<meta property="twitter:card" content="summary_large_image">
	<meta property="twitter:url" content="https://www.lumeral.fit">
	<meta property="twitter:title" content="Lumeral: Professional Portrait Photography">
	<meta property="twitter:description" content="Lumeral: Next-level portrait photography for personal and professional needs.">
	<meta property="twitter:image" content="https://www.lumeral.fit/logo.png">
	  
	  <!-- end custom header code -->
	  
	  <!-- code snippet for header -->
	  
	  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
	  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
	  <link rel="shortcut icon" href="/favicon.ico" />
	  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
	  <link rel="manifest" href="/site.webmanifest" />
	  
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
	<title>Lumeral Fitness Photography</title>
  
  
  <style>
	:root {
	  --card-width: 200px;
	  --card-height: 250px; /* 4:5 aspect ratio */
	  --glow-color: #7dd3fc; /* Light blue glow */
	  --bg-dark: #050505;
	}

	* {
	  box-sizing: border-box;
	  margin: 0;
	  padding: 0;
	  -webkit-user-select: none;
	  -moz-user-select: none;
	  -ms-user-select: none;
	  user-select: none;
	}

	html, body {
	  font-family: sans-serif;
	  background-color: var(--bg-dark);
	  color: #fff;
	  overflow: hidden;
	  height: 100vh;
	  width: 100vw;
	  position: relative;
	  touch-action: none;       /* crucial for chrome/android */
	  overscroll-behavior: none; /* prevents rubber-banding on mac/ios */
	}
	
	/* Block system zoom on all elements */
	* {
	  touch-action: none;
	}

	/* Starfield Canvas */
	#starfield {
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 0;
	  background: #000;
	}

	/* Nebula Gradient Overlay */
	#nebula {
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 0;
	  pointer-events: none;
	  background: 
		radial-gradient(ellipse at 20% 30%, rgba(30, 58, 138, 0.35) 0%, transparent 50%),
		radial-gradient(ellipse at 80% 70%, rgba(88, 28, 135, 0.28) 0%, transparent 50%),
		radial-gradient(ellipse at 50% 50%, rgba(15, 23, 42, 0.4) 0%, transparent 60%);
	  opacity: 1;
	}

	#container {
	  position: absolute;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 1;
	  touch-action: none; /* Let Three.js handle all touch, block system zoom */
	}

	/* --- The 3D Card --- */
	.element-card {
	  width: var(--card-width);
	  height: var(--card-height);
	  position: absolute;
	  transform-style: preserve-3d;
	  
	  /* Base State with rounded corners and subtle blue glow */
	  border-radius: 18px;
	  overflow: hidden;
	  background: rgba(255, 255, 255, 0.02);
	  border: 1px solid rgba(148, 163, 184, 0.7);
	  box-shadow: 
		0 16px 40px rgba(0, 0, 0, 0.9),
		0 0 18px rgba(56, 189, 248, 0.7);
	  
	  transition: box-shadow 0.25s ease, border-color 0.25s ease, transform 0.25s ease;
	  cursor: grab;
	  
	  pointer-events: auto;
	}
	
	/* Subtle blue glow overlay on cards 
	.element-card::before {
	  content: "";
	  position: absolute;
	  inset: -2px;
	  border-radius: inherit;
	  background: radial-gradient(circle at top, rgba(56, 189, 248, 0.16), rgba(15, 23, 42, 0.95));
	  mix-blend-mode: screen;
	  opacity: 0.85;
	  pointer-events: none;
	}
	*/
	
	/* Subtle blue glow overlay on cards (EDGE-ONLY; does not tint the photo) */
	.element-card::before {
	  content: "";
	  position: absolute;
	  inset: 0;
	  border-radius: inherit;
	  pointer-events: none;
	
	  /* Transparent layer with only shadows => keeps the face/tones unchanged */
	  box-shadow:
		inset 0 0 0 2px rgba(125, 211, 252, 0.35),
		inset 0 0 36px rgba(56, 189, 248, 0.10);
	}

	
	.element-card:active {
	  cursor: grabbing;
	}

	/* Hover State - Keep your existing cool glowing border */
	.element-card:hover {
	  box-shadow:
		0 0 0 3px rgba(125, 211, 252, 0.8),
		0 0 12px rgba(125, 211, 252, 0.5),
		0 0 24px rgba(125, 211, 252, 0.35),
		0 0 400px rgba(125, 211, 252, 0.4),
		inset 0 0 16px rgba(125, 211, 252, 0.1);
	  border-color: rgba(125, 211, 252, 0.8);
	}

	/* Image area */
	.card-image {
	  width: 100%;
	  height: 100%;
	  object-fit: cover;
	  display: block;
	  pointer-events: none;
	}

	/* --- Lightbox Overlay --- */
	#lightbox {
	  position: fixed;
	  inset: 0;
	  z-index: 1000;
	  background: rgba(0, 0, 0, 0.85);
	  backdrop-filter: blur(8px);
	  display: flex;
	  justify-content: center;
	  align-items: center;
	  opacity: 0;
	  pointer-events: none;
	  transition: opacity 0.3s ease;
	  touch-action: none; /* Prevent pinch-zoom crash on mobile */
	}

	#lightbox.active {
	  opacity: 1;
	  pointer-events: auto;
	  cursor: zoom-out;
	}

	#lightbox img {
	  max-width: 90vw;
	  max-height: 90vh;
	  border-radius: 4px;
	  box-shadow: 0 0 50px rgba(0,0,0,0.8);
	  transform: scale(0.95);
	  transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.3s ease;
	  user-select: none;
	  touch-action: none; /* Prevent pinch-zoom crash on mobile */
	}

	#lightbox.active img {
	  transform: scale(1);
	}

	/* --- UI Controls --- */
	#menu {
	  position: fixed;
	  bottom: 0;
	  width: 100%;
	  text-align: center;
	  z-index: 100;
	  pointer-events: none;
	}

	.button-group {
	  display: inline-flex;
	  background: rgba(20, 20, 20, 0.8);
	  backdrop-filter: blur(10px);
	  padding: 6px;
	  border-radius: 50px;
	  border: 1px solid rgba(255, 255, 255, 0.1);
	  pointer-events: auto;
	  gap: 5px;
	  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
	}

	button {
	  background: transparent;
	  border: none;
	  color: rgba(255, 255, 255, 0.6);
	  font-family: sans-serif;
	  font-size: 11px;
	  font-weight: 600;
	  text-transform: uppercase;
	  letter-spacing: 2px;
	  padding: 10px 24px;
	  cursor: pointer;
	  border-radius: 40px;
	  transition: all 0.3s ease;
	}

	button:hover {
	  color: #fff;
	  background: rgba(255, 255, 255, 0.1);
	}

	/* Active button with blue glow */
	button.active {
	  background: radial-gradient(circle at top, rgba(56, 189, 248, 0.38), rgba(8, 47, 73, 0.95));
	  color: #e5e7eb;
	  box-shadow:
		0 0 16px rgba(56, 189, 248, 0.95),
		0 0 40px rgba(8, 47, 73, 0.9);
	  transform: translateY(-0.5px);
	}

	/* Logo button in top-left corner */
	#logo-button {
	  position: fixed;
	  top: 20px;
	  left: 20px;
	  z-index: 200;
	  width: 60px;
	  height: 60px;
	  cursor: pointer;
	  opacity: 0.75;
	  transition: opacity 0.3s ease, transform 0.3s ease, filter 0.3s ease;
	  pointer-events: auto;
	  border-radius: 8px;
	  padding: 8px;
	  background: rgba(20, 20, 20, 0.6);
	  backdrop-filter: blur(10px);
	  border: 1px solid rgba(255, 255, 255, 0.1);
	  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
	}

	#logo-button:hover {
	  opacity: 1;
	  transform: scale(1.05);
	  filter: drop-shadow(0 0 8px rgba(125, 211, 252, 0.4));
	  border-color: rgba(125, 211, 252, 0.3);
	}

	#logo-button img {
	  width: 100%;
	  height: 100%;
	  object-fit: contain;
	  display: block;
	}
  </style>
</head>
<body>

  <!-- Starfield Background -->
  <canvas id="starfield"></canvas>
  
  <!-- Nebula Gradient Overlay -->
  <div id="nebula"></div>

  <!-- Logo button in top-left corner -->
  <a id="logo-button" href="https://lumeral.photo">
	<img src="https://lumeral.photo/images/plain%20logo.png" alt="Lumeral Logo" />
  </a>

  <!-- Lightbox Container -->
  <div id="lightbox">
	<img id="lightbox-img" src="" alt="Full size" />
  </div>

  <div id="container"></div>

  <div id="menu">
	<div class="button-group">
	  <button id="table">Curve</button>
	  <button id="sphere">Sphere</button>
	  <button id="helix">Helix</button>
	  <button id="grid">Grid</button>
	</div>
  </div>

  <!-- Three.js Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.131.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.131.1/examples/js/renderers/CSS3DRenderer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.131.1/examples/js/controls/TrackballControls.js"></script>
  <script src="https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>

  <script>
	// --- STARFIELD SETUP ---
	(function initStarfield() {
	  const canvas = document.getElementById('starfield');
	  const ctx = canvas.getContext('2d');
	  
	  function resizeCanvas() {
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	  }
	  
	  resizeCanvas();
	  window.addEventListener('resize', resizeCanvas);
	  
	  // Create stars with varying sizes and brightness
	  const stars = [];
	  const starCount = 800;
	  
	  for (let i = 0; i < starCount; i++) {
		stars.push({
		  x: Math.random() * canvas.width,
		  y: Math.random() * canvas.height,
		  radius: Math.random() * 1.5,
		  alpha: Math.random() * 0.5 + 0.3,
		  twinkleSpeed: Math.random() * 0.02 + 0.005,
		  twinklePhase: Math.random() * Math.PI * 2
		});
	  }
	  
	  function drawStars() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		
		stars.forEach(star => {
		  // Subtle twinkling effect
		  star.twinklePhase += star.twinkleSpeed;
		  const twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;
		  
		  ctx.beginPath();
		  ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
		  ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha * twinkle})`;
		  ctx.fill();
		  
		  // Add subtle glow to larger stars
		  if (star.radius > 1) {
			ctx.beginPath();
			ctx.arc(star.x, star.y, star.radius * 2, 0, Math.PI * 2);
			ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha * twinkle * 0.15})`;
			ctx.fill();
		  }
		});
		
		requestAnimationFrame(drawStars);
	  }
	  
	  drawStars();
	})();

	// ==============================================
	// CONFIGURATION: Set your local image folders here
	// ==============================================
	const THUMBNAIL_FOLDER = './thumbnails/';  // Folder containing 400x500 images
	const FULLSIZE_FOLDER = './fullsize/';     // Folder containing 1600x2000 images
	
	// List your image filenames here (must exist in both folders)
	const IMAGE_FILES = [
	  'photo-00001.jpg',
	  'photo-00002.jpg',
	  'photo-00003.jpg',
	  'photo-00004.jpg',
	  'photo-00005.jpg',
	  'photo-00006.jpg',
	  'photo-00007.jpg',
	  'photo-00008.jpg',
	  'photo-00009.jpg',
	  'photo-00010.jpg',
	  	'photo-00011.jpg',
	  	'photo-00012.jpg',
	  	'photo-00013.jpg',
		'photo-00014.jpg',
		'photo-00015.jpg',
		'photo-00016.jpg',
		'photo-00017.jpg',
		'photo-00018.jpg',
		'photo-00019.jpg',
		'photo-00020.jpg',
		'photo-00021.jpg',
		'photo-00022.jpg',
		'photo-00023.jpg',
		'photo-00024.jpg',
		'photo-00025.jpg',
		'photo-00026.jpg',
		'photo-00027.jpg',
		'photo-00028.jpg',
		'photo-00029.jpg',
		'photo-00030.jpg',
		'photo-00031.jpg',
		'photo-00032.jpg',
		'photo-00033.jpg',
		'photo-00034.jpg',
		'photo-00035.jpg',
		'photo-00036.jpg',
		'photo-00037.jpg',
		'photo-00038.jpg',
		'photo-00039.jpg',
		'photo-00040.jpg',
		'photo-00041.jpg',
		'photo-00042.jpg',
		'photo-00043.jpg',
		'photo-00044.jpg',
		'photo-00045.jpg',
		'photo-00046.jpg',
		'photo-00047.jpg',
		'photo-00048.jpg',
		'photo-00049.jpg',
		'photo-00050.jpg',
		'photo-00051.jpg',
		'photo-00052.jpg',
		'photo-00053.jpg',
		'photo-00054.jpg',
		'photo-00055.jpg',
		'photo-00056.jpg',
		'photo-00057.jpg',
		'photo-00058.jpg',
		'photo-00059.jpg',
		'photo-00060.jpg',
		'photo-00061.jpg',
		'photo-00062.jpg',
		'photo-00063.jpg',
		'photo-00064.jpg',
		'photo-00065.jpg',
		'photo-00066.jpg',
		'photo-00067.jpg',
		'photo-00068.jpg',
		'photo-00069.jpg',
		'photo-00070.jpg',
		'photo-00071.jpg',
		'photo-00072.jpg',
		'photo-00073.jpg',
		'photo-00074.jpg',
		'photo-00075.jpg',
		'photo-00076.jpg',
		'photo-00077.jpg',
		'photo-00078.jpg',
		'photo-00079.jpg',
		'photo-00080.jpg',
		'photo-00081.jpg',
		'photo-00082.jpg',
		'photo-00083.jpg',
		'photo-00084.jpg',
		'photo-00085.jpg',
		'photo-00086.jpg',
		'photo-00087.jpg',
		'photo-00088.jpg',
		'photo-00089.jpg',
		'photo-00090.jpg',
		'photo-00091.jpg',
		'photo-00092.jpg',
		'photo-00093.jpg',
		'photo-00094.jpg',
		'photo-00095.jpg',
		'photo-00096.jpg',
		'photo-00097.jpg',
		'photo-00098.jpg',
		'photo-00099.jpg',
		'photo-00100.jpg',
		'photo-00101.jpg',
		'photo-00102.jpg',
		'photo-00103.jpg',
		'photo-00104.jpg',
		'photo-00105.jpg',
		'photo-00106.jpg',
		'photo-00107.jpg',
		'photo-00108.jpg',
	  
	  // Add more filenames here...
	];
	
	const ITEM_COUNT = IMAGE_FILES.length;

	// Fisher-Yates shuffle to randomize the photo order on each page load
	function shuffleArray(array) {
	  for (let i = array.length - 1; i > 0; i--) {
	    const j = Math.floor(Math.random() * (i + 1));
	    [array[i], array[j]] = [array[j], array[i]];
	  }
	  return array;
	}

	// Shuffle the photos each time the page loads
	shuffleArray(IMAGE_FILES);
	// ==============================================

	let camera, scene, renderer, controls;
	let sceneGroup;
	const objects = [];
	const targets = { table: [], sphere: [], helix: [], grid: [] };
	
	let skipNextControlsUpdate = false;
	let initialSpinVelocity = 0;
	let isLightboxOpen = false;

	init();
	animate();

	// Helper function to get photo URLs
	function getPhotoUrls(index) {
	  const filename = IMAGE_FILES[index];
	  return {
		thumbnail: THUMBNAIL_FOLDER + filename,
		fullsize: FULLSIZE_FOLDER + filename
	  };
	}

	function init() {
	  const container = document.getElementById('container');

	  camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
	  camera.position.z = 2400;

	  scene = new THREE.Scene();
	  
	  // Create a group to hold all photos. This allows us to rotate the "universe" 
	  // independently of the camera interaction.
	  sceneGroup = new THREE.Group();
	  scene.add(sceneGroup);

	  // --- CREATE OBJECTS ---
	  for (let i = 0; i < ITEM_COUNT; i++) {
		const urls = getPhotoUrls(i);

		// 1. DOM Element
		const element = document.createElement('div');
		element.className = 'element-card';
		// element.style.backgroundColor = 'rgba(0,0,0,' + (Math.random() * 0.5 + 0.25) + ')';
		element.style.backgroundColor = 'transparent';


		const img = document.createElement('img');
		img.className = 'card-image';
		img.src = urls.thumbnail;
		img.loading = "lazy"; 
		element.appendChild(img);

		// --- INTERACTION LOGIC (Click vs Drag) ---
		// Store the full-size URL on the element for the global handler to access
		element.dataset.fullsizeUrl = urls.fullsize;
		
		element.addEventListener('pointerdown', (e) => {
		  // Store click start info globally
		  window._cardClickStart = {
		    x: e.clientX,
		    y: e.clientY,
		    time: performance.now(),
		    fullsizeUrl: urls.fullsize
		  };
		});

		// 2. CSS3D Object
		const objectCSS = new THREE.CSS3DObject(element);
		objectCSS.position.x = Math.random() * 4000 - 2000;
		objectCSS.position.y = Math.random() * 4000 - 2000;
		objectCSS.position.z = Math.random() * 4000 - 2000;
		
		sceneGroup.add(objectCSS);
		objects.push(objectCSS);
	  }

	  // --- LAYOUTS ---
	  
	  // 1. CURVED WALL
	  {
		const cols = 12;
		const xStep = 220;
		const yStep = 270;
		for (let i = 0; i < objects.length; i++) {
		  const object = new THREE.Object3D();
		  const col = i % cols;
		  const row = Math.floor(i / cols);
		  const xPos = (col * xStep) - ((cols * xStep) / 2);
		  const yPos = -(row * yStep) + ((objects.length / cols * yStep) / 2);
		  // Cylinder curve
		  const radius = 2500;
		  const theta = xPos / radius; 
		  object.position.x = radius * Math.sin(theta);
		  object.position.y = yPos;
		  object.position.z = radius * Math.cos(theta) - radius + 200; // Offset to center
		  
		  const vector = new THREE.Vector3(object.position.x * 2, object.position.y, object.position.z * 2);
		  object.lookAt(0, object.position.y, 4000); // Face vaguely center
		  targets.table.push(object);
		}
	  }

	  // 2. SPHERE
	  {
		const vector = new THREE.Vector3();
		for (let i = 0; i < objects.length; i++) {
		  const object = new THREE.Object3D();
		  const phi = Math.acos(-1 + (2 * i) / objects.length);
		  const theta = Math.sqrt(objects.length * Math.PI) * phi;
		  const radius = 900;
		  object.position.setFromSphericalCoords(radius, phi, theta);
		  vector.copy(object.position).multiplyScalar(2);
		  object.lookAt(vector);
		  targets.sphere.push(object);
		}
	  }

	  // 3. HELIX
	  {
		const vector = new THREE.Vector3();
		for (let i = 0; i < objects.length; i++) {
		  const object = new THREE.Object3D();
		  const radius = 1000;
		  const theta = 0.25 * i;
		  const y = -(i * 15) + 600;

		  object.position.x = radius * Math.sin(theta);
		  object.position.y = y;
		  object.position.z = radius * Math.cos(theta);

		  vector.set(object.position.x * 2, object.position.y, object.position.z * 2);
		  object.lookAt(vector);

		  targets.helix.push(object);
		}
	  }

	  // 4. GRID
		{
		  for (let i = 0; i < objects.length; i++) {
			const object = new THREE.Object3D();
			const width = 240;
			const height = 290;
			
			// 1. Columns: Change % 5 to % 6
			// Offset changed from -500 to -600 to center the wider grid
			object.position.x = ((i % 6) * width) - 600;
	  
			// 2. Rows: Change / 5 to / 6 AND % 5 to % 6
			// Offset changed from +500 to +725 to center the taller grid
			object.position.y = (-(Math.floor(i / 6) % 6) * height) + 725;
	  
			// 3. Depth: Change / 25 to / 36 (Because 6 * 6 = 36)
			// Change - 2000 to - 1000 to center the 3 layers
			object.position.z = (Math.floor(i / 36)) * 1000 - 1000;
			
			targets.grid.push(object);
		  }
		}

	  // --- RENDERER ---
	  renderer = new THREE.CSS3DRenderer();
	  renderer.setSize(window.innerWidth, window.innerHeight);
	  container.appendChild(renderer.domElement);

	  // --- CONTROLS ---
	  controls = new THREE.TrackballControls(camera, renderer.domElement);
	  controls.noPan = true; // <--- ADD THIS LINE HERE
	  controls.minDistance = 1500;
	  controls.maxDistance = 20000;
	  controls.rotateSpeed = 1.0; 
	  controls.zoomSpeed = 1.2;
	  // controls.panSpeed = 0.8;
	  controls.staticMoving = false; 
	  controls.dynamicDampingFactor = 0.05; // Lower = more floaty (was 0.08) 

	  // Capture-phase listener to skip controls update on click (prevents burst)
	  document.addEventListener('pointerdown', () => {
		skipNextControlsUpdate = true;
		initialSpinVelocity = 0; // Stop initial spin on user interaction
	  }, true);

	  // Buttons
	  const buttonTable = document.getElementById('table');
	  const buttonSphere = document.getElementById('sphere');
	  const buttonHelix = document.getElementById('helix');
	  const buttonGrid = document.getElementById('grid');

	  buttonTable.addEventListener('click', function () { transform(targets.table, 2000); setActive(this); });
	  buttonSphere.addEventListener('click', function () { transform(targets.sphere, 2000); setActive(this); });
	  buttonHelix.addEventListener('click', function () { transform(targets.helix, 2000); setActive(this); });
	  buttonGrid.addEventListener('click', function () { transform(targets.grid, 2000); setActive(this); });

	  // Start gentle spin immediately so scene rotates during assembly
	  initialSpinVelocity = 0.095;
	  
	  transform(targets.table, 2000);
	  setActive(buttonTable);

	  window.addEventListener('resize', onWindowResize);
	  
	  // Lightbox listeners
	  document.getElementById('lightbox').addEventListener('click', closeLightbox);
	  // Prevent ALL zoom gestures on lightbox
	  const lb = document.getElementById('lightbox');
	  lb.addEventListener('touchstart', (e) => {
	    if (e.touches.length > 1) e.preventDefault();
	  }, { passive: false });
	  lb.addEventListener('touchmove', (e) => {
	    e.preventDefault();
	  }, { passive: false });
	  // Safari-specific gesture events
	  lb.addEventListener('gesturestart', (e) => e.preventDefault());
	  lb.addEventListener('gesturechange', (e) => e.preventDefault());
	  lb.addEventListener('gestureend', (e) => e.preventDefault());
	  
	  // Global pointerup handler to detect clicks on cards
	  // This works around TrackballControls capturing pointer events
	  window.addEventListener('pointerup', (e) => {
	    if (window._cardClickStart) {
	      const start = window._cardClickStart;
	      const dx = Math.abs(e.clientX - start.x);
	      const dy = Math.abs(e.clientY - start.y);
	      const dt = performance.now() - start.time;
	      
	      // If moved less than 5px and released within 300ms, it's a click
	      if (dx < 5 && dy < 5 && dt < 300) {
	        openLightbox(start.fullsizeUrl);
	      }
	      
	      window._cardClickStart = null;
	    }
	  });
	  
	  // --- FIX FOR MOBILE CRASHES ---
		// 1. Disable native Safari page zoom (pinch) everywhere.
		// This allows TrackballControls to handle the pinch math without the browser interfering.
		document.addEventListener('gesturestart', (e) => e.preventDefault());
		document.addEventListener('gesturechange', (e) => e.preventDefault());
		document.addEventListener('gestureend', (e) => e.preventDefault());
		
		// 2. Disable native browser zoom on Chrome/Android (passive: false is required)
		window.addEventListener('touchmove', (e) => {
		  // If two fingers are used, prevent native zoom so Three.js handles it
		  if (e.touches.length > 1) {
			e.preventDefault();
		  }
		}, { passive: false });
	}

	// --- LIGHTBOX FUNCTIONS ---
	function openLightbox(fullsizeUrl) {
	  isLightboxOpen = true;
	  
	  const lb = document.getElementById('lightbox');
	  const img = document.getElementById('lightbox-img');
	  
	  // Hide the image while loading to prevent showing previous image
	  img.style.opacity = '0';
	  
	  // Create a new image to preload
	  const tempImg = new Image();
	  tempImg.onload = function() {
	    // Once loaded, update the src and fade in
	    img.src = fullsizeUrl;
	    img.style.opacity = '1';
	  };
	  tempImg.src = fullsizeUrl;
	  
	  lb.classList.add('active');
	}

	function closeLightbox() {
	  isLightboxOpen = false;
	  const lb = document.getElementById('lightbox');
	  const img = document.getElementById('lightbox-img');
	  lb.classList.remove('active');
	  // Reset opacity for next time
	  setTimeout(() => {
	    if (!isLightboxOpen) img.style.opacity = '0';
	  }, 300); // Wait for fade out transition
	}

	function setActive(button) {
	  document.querySelectorAll('.button-group button').forEach(b => b.classList.remove('active'));
	  button.classList.add('active');
	  
	  new TWEEN.Tween(sceneGroup.rotation)
		.to({ x: 0, y: 0, z: 0 }, 2000)
		.easing(TWEEN.Easing.Quadratic.Out)
		.start();
	}

	function transform(targets, duration) {
	  TWEEN.removeAll();

	  for (let i = 0; i < objects.length; i++) {
		const object = objects[i];
		const target = targets[i];

		new TWEEN.Tween(object.position)
		  .to({ x: target.position.x, y: target.position.y, z: target.position.z }, Math.random() * duration + duration)
		  .easing(TWEEN.Easing.Exponential.InOut)
		  .start();

		new TWEEN.Tween(object.rotation)
		  .to({ x: target.rotation.x, y: target.rotation.y, z: target.rotation.z }, Math.random() * duration + duration)
		  .easing(TWEEN.Easing.Exponential.InOut)
		  .start();
	  }
	}

	function onWindowResize() {
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();
	  renderer.setSize(window.innerWidth, window.innerHeight);
	  
	  // Resize starfield canvas
	  const canvas = document.getElementById('starfield');
	  canvas.width = window.innerWidth;
	  canvas.height = window.innerHeight;
	}

	function animate() {
	  requestAnimationFrame(animate);
	  TWEEN.update();
	  
	  // IMPORTANT FIX: 
	  // Only update controls if Lightbox is CLOSED.
	  // This prevents the "burst" because controls stop calculating inertia 
	  // the moment the click is detected.
	  if (!isLightboxOpen) {
		if (skipNextControlsUpdate) {
		  skipNextControlsUpdate = false;
		} else {
		  controls.update();
		}
		
		// Hard clamp camera distance to prevent mobile memory crash on fast zoom
		const dist = camera.position.length();
		const minDist = 1800;
		if (dist < minDist) {
		  camera.position.multiplyScalar(minDist / dist);
		}
	  }
	  
	  // Apply initial spin with smooth exponential decay
	  if (initialSpinVelocity > 0.00001) {
	    sceneGroup.rotation.y += initialSpinVelocity;
	    initialSpinVelocity *= 0.993; // Tuned for ~4 second coast to stop
	  }
	  
	  renderer.render(scene, camera);
	}
  </script>
</body>
</html>
