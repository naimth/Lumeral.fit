<!DOCTYPE html>
<html lang="en">
<head>
	
	<!--Custom Header Code:21-->
	
		
	<!-- Custom Header Code For lumeral.com -->
  <meta name="keywords" content="lumeral, Lumeral, photos, portraits, headshots">
  <meta name="description" content="Lumeral: Next-level portrait photography for personal and professional needs.">
  
  <link rel="canonical" href="https://www.lumeral.photo" />
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://www.lumeral.com">
  <meta property="og:title" content="Lumeral: Professional Portrait Photography">
  <meta property="og:description" content="Lumeral: Next-level portrait photography for personal and professional needs.">
  <meta property="og:image" content="https://www.lumeral.com/logo.png">
  <meta property="og:site_name" content="Lumeral">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:locale" content="en_US"> 
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://www.lumeral.com">
  <meta property="twitter:title" content="Lumeral: Professional Portrait Photography">
  <meta property="twitter:description" content="Lumeral: Next-level portrait photography for personal and professional needs.">
  <meta property="twitter:image" content="https://www.lumeral.com/logo.png">
	
	<!-- end custom header code -->
	
	<!-- code snippet for header -->
	
	<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
	<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
	<link rel="manifest" href="/site.webmanifest" />
	
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lumeral</title>
  <style>
	html, body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
	canvas { display: block; cursor: grab; }
	canvas:active { cursor: grabbing; }
	#loader { position: absolute; inset: 0; display: grid; place-items: center; color: #fff; font-size: 1rem; text-align: center; }
  /* === Enhanced Loader + Cinematic Fade === */
canvas { opacity: 0; transition: opacity 1.2s ease-in-out; }
#loader { position: absolute; inset: 0; display: grid; place-items: center; z-index: 99999;
  color: #fff; background: radial-gradient(120% 120% at 50% 50%, #0b0b10 0%, #000 60%); opacity: 1; transition: opacity 0.8s ease; }
#loader .loader-wrap { position: relative; display: flex; flex-direction: column; align-items: center; gap: 12px; }
#loader .spinner-ring { width: 68px; height: 68px; border: 4px solid rgba(255,255,255,0.15);
  border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
#loader .spinner-dot { position: absolute; top: 6px; width: 14px; height: 14px; border-radius: 50%; background: #fff;
  animation: pulse 1.5s ease-in-out infinite; }
#loader .loader-text { font-size: 14px; text-align: center; opacity: 0.95; }
#loader .ellipsis span { animation: blink 1.4s infinite steps(1, end); display: inline-block; }
#loader .ellipsis span:nth-child(2) { animation-delay: .2s; } 
#loader .ellipsis span:nth-child(3) { animation-delay: .4s; }
#loader #loader-bar { width: 240px; height: 4px; background: rgba(255,255,255,0.18); margin: 10px auto 6px; border-radius: 999px; overflow: hidden; }
#loader #loader-bar-fill { width: 0%; height: 100%; background: #fff; transition: width .2s ease; }
#loader #loader-pct { font-variant-numeric: tabular-nums; font-size: 12px; opacity: 0.8; }
@keyframes spin { to { transform: rotate(360deg); } }
@keyframes pulse { 0%,100%{ transform: scale(1); opacity: .6 } 50%{ transform: scale(1.6); opacity: 1 } }
@keyframes blink { 0%{ opacity: 0 } 50%{ opacity: 1 } 100%{ opacity: 0 } }
</style>
  <!-- Three.js (r128) and examples -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/DecalGeometry.js"></script>
</head>
<body>
  <div id="loader">
  <div class="loader-wrap">
    <div class="spinner-ring"></div>
    <div class="spinner-dot"></div>
    <div class="loader-text">
      <span id="loader-text">Loading</span>
      <span class="ellipsis"><span>.</span><span>.</span><span>.</span></span>
      <div id="loader-bar"><div id="loader-bar-fill"></div></div>
      <div id="loader-pct">0%</div>
    </div>
  </div>
</div>
  <canvas id="gl-canvas"></canvas>

  <script>
	// Wait for examples scripts
	window.onload = function () { console.log('[init] window.onload fired');
	  const canvas = document.getElementById('gl-canvas');
	  const loaderEl = document.getElementById('loader');

  // === Loader refs & cinematic fade-in ===
  const loaderTextEl = document.getElementById('loader-text');
  const loaderPctEl = document.getElementById('loader-pct');
  const loaderBarFillEl = document.getElementById('loader-bar-fill');

  function easeInOutCubic(t){ return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2; }

  function cinematicReveal(){
    try {
      // Cross-fade canvas in, loader out
      canvas.style.opacity = '1';
      loaderEl.style.opacity = '0';
      setTimeout(() => { if (loaderEl && loaderEl.parentNode) loaderEl.parentNode.removeChild(loaderEl); }, 900);

      // Optional: tone-mapping exposure ramp for a cinematic lift
      const endExp = renderer.toneMappingExposure || 1.0;
      const startExp = Math.max(0.12, endExp * 0.12);
      renderer.toneMappingExposure = startExp;
      const start = performance.now();
      const D = 1400;
      function step(ts){
        const t = Math.min(1, (ts - start) / D);
        const e = easeInOutCubic(t);
        renderer.toneMappingExposure = startExp + (endExp - startExp) * e;
        if (t < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    } catch (_e) { /* noop */ }
  }

  // Shared loading manager to drive the progress UI
  const loadingManager = new THREE.LoadingManager();
  loadingManager.onStart = () => {
    if (loaderTextEl) loaderTextEl.textContent = 'Preparing';
  };
  loadingManager.onProgress = (_url, itemsLoaded, itemsTotal) => {
    const pct = itemsTotal > 0 ? Math.round((itemsLoaded / itemsTotal) * 100) : Math.min(99, (itemsLoaded||0)*10);
    if (loaderPctEl) loaderPctEl.textContent = pct + '%';
    if (loaderBarFillEl) loaderBarFillEl.style.width = pct + '%';
  };
  loadingManager.onLoad = () => {
    if (loaderTextEl) loaderTextEl.textContent = 'Ready';
    if (loaderPctEl) loaderPctEl.textContent = '100%';
    if (loaderBarFillEl) loaderBarFillEl.style.width = '100%';
    setTimeout(cinematicReveal, 250); // small buffer to ensure first frame is drawn
  };

	  // --- Scene / Camera / Renderer ---
	  const scene = new THREE.Scene();
	  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
	  camera.position.set(0, 0, 5);

	  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
	  renderer.setSize(window.innerWidth, window.innerHeight);
	  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
	  renderer.setClearColor(0x000000, 1);
	  renderer.toneMapping = THREE.ACESFilmicToneMapping;
	  renderer.toneMappingExposure = 1.25;
	  renderer.outputEncoding = THREE.sRGBEncoding;
	  renderer.autoClear = false;

	  // --- Controls ---
	  const controls = new THREE.OrbitControls(camera, renderer.domElement);
	  

    // === Zoom-out-then-navigate action for the hot decal (inside onload scope) ===
    function zoomOutThenNavigate(url, durationMs) {
  const target = (typeof controls !== 'undefined' && controls.target) ? controls.target.clone() : new THREE.Vector3(0,0,0);
  const startPos = camera.position.clone();
  const dir = startPos.clone().sub(target).normalize();
  const startDist = startPos.distanceTo(target);

  let maxByControls = (typeof controls !== 'undefined' && isFinite(controls.maxDistance)) ? controls.maxDistance : Infinity;
  let maxByCamera = camera.far * 0.95;
  let endDist = Math.min(maxByControls, maxByCamera);
  if (!isFinite(endDist)) endDist = maxByCamera;
  if (endDist <= startDist) endDist = startDist + 1.0;

  const prevEnabled = typeof controls !== 'undefined' ? controls.enabled : true;
  let prevAutoRotate = false;
  if (typeof controls !== 'undefined') {
    prevAutoRotate = controls.autoRotate;
    controls.enabled = false;
    controls.autoRotate = false;
  }

  const start = performance.now();
  // 3 seconds default unless overridden by caller
  const dur = Math.max(100, (durationMs|0) || 3000);

  // Ease-in cubic: starts slow and accelerates (t^3)
  function easeInQuint(t){ return t*t*t*t*t; }

  function step(ts) {
    const t = Math.min(1, (ts - start) / dur);
    const e = easeInQuint(t);
    const d = startDist + (endDist - startDist) * e;
    const newPos = target.clone().add(dir.clone().multiplyScalar(d));
    camera.position.copy(newPos);
    camera.lookAt(target);
    camera.updateProjectionMatrix();
    if (typeof controls !== 'undefined') controls.update();

    try {
      if (typeof finalComposer !== 'undefined' && finalComposer) { finalComposer.render(); }
      else { renderer.render(scene, camera); }
    } catch (_){ /* noop */ }

    if (t < 1) {
      requestAnimationFrame(step);
    } else {
      if (typeof controls !== 'undefined') {
        controls.enabled = prevEnabled;
        controls.autoRotate = prevAutoRotate;
      }
      // Same-tab navigation after the zoom (keeps history)
      window.location.href = url;
    }
  }
  requestAnimationFrame(step);
}

    function onHotButtonPress(ev) {
      zoomOutThenNavigate('https://lumeral.photo', 1000);
    }
    // === End zoom-out-then-navigate ===

controls.enableDamping = true;
	  controls.dampingFactor = 0.05;
	  controls.screenSpacePanning = false;
	  controls.enableZoom = true;
	  controls.enablePan = false;
	  controls.autoRotate = true;
	  controls.autoRotateSpeed = 0.3;

	  // --- Starfield ---
	  let starSpriteTex = null;
	  (function createStarfield(){
		const starVertices = [];
		for (let i = 0; i < 15000; i++) {
		  starVertices.push(
			THREE.MathUtils.randFloatSpread(2000),
			THREE.MathUtils.randFloatSpread(2000),
			THREE.MathUtils.randFloatSpread(2000)
		  );
		}
		const geometry = new THREE.BufferGeometry();
		geometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
		const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, sizeAttenuation: true, map: (starSpriteTex || (starSpriteTex = createStarSpriteTexture())), transparent: true, alphaTest: 0.2, depthWrite: false });
		const stars = new THREE.Points(geometry, material);
		// Put stars on BLOOM layer so they glow
		try { stars.layers.set(1); } catch(_) {}
		stars.name = 'starfield';
		scene.add(stars);
	  })();

	  // --- Lighting ---
	  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
	  const flareLight = new THREE.PointLight(0xffddaa, 3.5, 4000);
	  flareLight.position.set(8, 2, 0);
	  scene.add(flareLight);
	  // Visible star mesh for the light (bloom target)
	  try{
		const starGeo = new THREE.SphereGeometry(0.6, 24, 24);
		const starMat = new THREE.MeshBasicMaterial({ color: 0xffeebf, blending: THREE.AdditiveBlending });
		const starMesh = new THREE.Mesh(starGeo, starMat);
		starMesh.name = 'flareStar';
		starMesh.position.set(0, 0, 0);
		starMesh.layers.enable(1); // BLOOM layer
		flareLight.add(starMesh);
	  }catch(_){}

	  // --- Postprocessing (borrowed from your baseline variant) ---
	  const BASE_LAYER = 0, BLOOM_LAYER = 1;
	  const bloomLayer = new THREE.Layers(); bloomLayer.set(BLOOM_LAYER);
	  const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black', side: THREE.DoubleSide });
	  const _savedMats = {};
	  function darkenNonBloomed(obj){
		if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
		  _savedMats[obj.uuid] = obj.material; obj.material = darkMaterial;
		}
	  }
	  function restoreMaterial(obj){ if (_savedMats[obj.uuid]){ obj.material = _savedMats[obj.uuid]; delete _savedMats[obj.uuid]; } }

	  let bloomComposer, finalComposer, bloomPass, godRaysPass, flarePass, finalPass, occlusionRenderTarget, effectsPass, modelRoot, photoRoot, starOccMat, depthMaskRT, maskMaterial, lastBoundRadius; const ROT_SPEED = 0.0015;  // effectsPass alias for back-compat
	  
	  let hotButton = null, hotButtonMat = null;
	  const raycaster = new THREE.Raycaster();

// === Press+Release over decal only (prevents release-only triggering) ===
(function(){
  const MOVE_TOL = 6; // px tolerance before we treat as a drag/cancel
  let downOnHot = false;
  let downXY = { x: 0, y: 0 };

  function pointerToNDC(ev) {
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  }

  canvas.addEventListener('pointerdown', (ev) => {
    downOnHot = false;
    if (!hotButton) return;
    downXY.x = ev.clientX; downXY.y = ev.clientY;
    pointerToNDC(ev);
    raycaster.setFromCamera(pointer, camera);
    const hits = raycaster.intersectObject(hotButton, true);
    downOnHot = hits && hits.length > 0;
    // Optional: disable orbiting while pressing the decal
    // if (downOnHot && typeof controls !== 'undefined') controls.enabled = false;
  }, { passive: true });

  canvas.addEventListener('pointermove', (ev) => {
    if (!downOnHot) return;
    if (Math.hypot(ev.clientX - downXY.x, ev.clientY - downXY.y) > MOVE_TOL) {
      downOnHot = false; // cancel "click" if dragging
      // if (typeof controls !== 'undefined') controls.enabled = true;
    }
  }, { passive: true });

  canvas.addEventListener('pointerup', (ev) => {
    if (!hotButton) { downOnHot = false; return; }
    const wasDownOnHot = downOnHot;
    downOnHot = false;
    pointerToNDC(ev);
    raycaster.setFromCamera(pointer, camera);
    const upHits = raycaster.intersectObject(hotButton, true);
    const upOnHot = upHits && upHits.length > 0;
    // if (typeof controls !== 'undefined') controls.enabled = true;

    if (wasDownOnHot && upOnHot) {
      if (typeof onHotButtonPress === 'function') {
        onHotButtonPress(ev);
      }
      ev.stopPropagation();
    }
}, { passive: true });

  canvas.addEventListener('pointerleave', () => { downOnHot = false; });
  canvas.addEventListener('pointercancel', () => { downOnHot = false; });
})();
// === End press+release patch ===


	  const pointer = new THREE.Vector2();


	  function createProceduralDirtTexture(){
		const size = 1024; const c = document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
		ctx.fillStyle = '#111'; ctx.fillRect(0,0,size,size);
		for(let i=0;i<100;i++){ const x=Math.random()*size, y=Math.random()*size, r=Math.random()*40+5, a=Math.random()*0.1+0.05; ctx.fillStyle=`rgba(255,255,255,${a})`; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
		const tex = new THREE.CanvasTexture(c); tex.encoding = THREE.sRGBEncoding; return tex;
	  }

	  function createStarSpriteTexture(){
		const size=128; const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
		ctx.clearRect(0,0,size,size);
		const grd=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size*0.5);
		grd.addColorStop(0.0,'rgba(255,255,255,1.0)');
		grd.addColorStop(0.4,'rgba(255,255,255,0.9)');
		grd.addColorStop(1.0,'rgba(255,255,255,0.0)');
		ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(size/2,size/2,size*0.5,0,Math.PI*2); ctx.fill();
		const t=new THREE.CanvasTexture(c); t.encoding=THREE.sRGBEncoding; t.wrapS=THREE.ClampToEdgeWrapping; t.wrapT=THREE.ClampToEdgeWrapping; t.needsUpdate=true; return t;
	  }
	  
	  

// === GENERIC: Place a decal on a specific bounding-box face with vertical orientation ===
// axis: 'X' | 'Y' | 'Z'  (which normal axis to use)
// sign: +1 or -1         (which side along that axis)
// Returns { decalPos, euler, sizeVec }
function placeDecalOnFaceWithUp(targetMesh, axis='Z', sign=+1) {
  const bbox   = new THREE.Box3().setFromObject(targetMesh);
  const center = bbox.getCenter(new THREE.Vector3());
  const size   = bbox.getSize(new THREE.Vector3());
  const half   = size.clone().multiplyScalar(0.5);

  // Pick the local face center & normal based on axis/sign
  let localOnFace, localNormal;
  if (axis === 'X') {
    localOnFace = new THREE.Vector3(center.x + sign * half.x, center.y, center.z);
    localNormal = new THREE.Vector3(sign, 0, 0);
  } else if (axis === 'Y') {
    localOnFace = new THREE.Vector3(center.x, center.y + sign * half.y, center.z);
    localNormal = new THREE.Vector3(0, sign, 0);
  } else { // 'Z'
    localOnFace = new THREE.Vector3(center.x, center.y, center.z + sign * half.z);
    localNormal = new THREE.Vector3(0, 0, sign);
  }

  // Face point & normal in world space
  const worldOnFace = localOnFace.clone().applyMatrix4(targetMesh.matrixWorld);
  const worldNormal = localNormal.clone().transformDirection(targetMesh.matrixWorld).normalize();

  // Projector depth along the normal (use the half-length along the chosen axis)
  const axisHalf = (axis === 'X') ? half.x : (axis === 'Y' ? half.y : half.z);
  const projectorDepth = Math.max(axisHalf * 0.12, 0.001);
  const outward = projectorDepth * 0.25; // keep the decal box intersecting the surface
  const decalPos = worldOnFace.clone().add(worldNormal.clone().multiplyScalar(outward));

  // Build an orthonormal basis where:
  // - Z axis == worldNormal (out of the surface)
  // - Y axis == world up projected onto the plane (to keep the decal vertical)
  const worldUp = new THREE.Vector3(0, 1, 0);
  let yAxis = worldUp.clone().sub(worldNormal.clone().multiplyScalar(worldUp.dot(worldNormal)));
  if (yAxis.lengthSq() < 1e-6) { // if normal is nearly vertical, pick X as a fallback
    yAxis = new THREE.Vector3(1,0,0);
  }
  yAxis.normalize();
  const xAxis = new THREE.Vector3().crossVectors(yAxis, worldNormal).normalize();

  // Compose rotation matrix from basis [xAxis, yAxis, worldNormal]
  const rot = new THREE.Matrix4().makeBasis(xAxis, yAxis, worldNormal);
  const euler = new THREE.Euler().setFromRotationMatrix(rot, "XYZ");

  // Size: width along decal X (horizontal), height along decal Y (vertical), depth along decal Z (normal)
  const width  = Math.max(half.y * 0.6, 0.001); // span a good chunk vertically if we rotate in-plane
  const height = Math.max(half.y * 0.6, 0.001);
  const depth  = projectorDepth;

  return { decalPos, euler, sizeVec: new THREE.Vector3(width, height, depth) };
}
// === BEGIN: Decal placement on specific book face (pages side) ===
// Assumption: pages are on the +X face in the model's LOCAL space.
// If your model has pages at -X, set SIGN to -1 below.
function placeDecalOnBookPagesFace(modelMesh) {
  const bbox   = new THREE.Box3().setFromObject(modelMesh);
  const center = bbox.getCenter(new THREE.Vector3());
  const size   = bbox.getSize(new THREE.Vector3());
  const half   = size.clone().multiplyScalar(0.5);

  const SIGN = -1; // model-specific: pages are at -X (spine at +X)

  // Center point on the selected face
  const localOnFace = new THREE.Vector3(center.x + SIGN * half.x, center.y, center.z);
  // To world
  const worldOnFace = localOnFace.clone().applyMatrix4(modelMesh.matrixWorld);

  // Face normal in local space (Â±X), then to world space
  const localNormal = new THREE.Vector3(SIGN, 0, 0);
  const worldNormal = localNormal.clone().transformDirection(modelMesh.matrixWorld).normalize();

  // Nudge outward so it floats above the surface
  const projectorDepth = Math.max(half.x * 0.12, 0.001);
  const outward = projectorDepth * 0.25; // keep within half-depth
  const decalPos = worldOnFace.clone().add(worldNormal.clone().multiplyScalar(outward));

  // Orient decal so +Z faces outward along the normal
  const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), worldNormal);
  const orientation = new THREE.Euler().setFromQuaternion(quat, "XYZ");

  // Size: width along Y, height along Z, shallow depth along X
  const widthY  = Math.max(half.y * 0.6, 0.001);
  const heightZ = Math.max(half.z * 0.6, 0.001);
  const depthZ  = projectorDepth;
  const sizeVec = new THREE.Vector3(widthY, heightZ, depthZ);

  return { decalPos, orientation, sizeVec };
}
// === END: Decal placement on specific book face (pages side) ===


// === Robust pages-face placement using LOCAL geometry bounds ===
// Finds the center of the +X face in *local space* and converts to world space.
// Flip SIGN to -1 if your pages are on -X in local space.
function placeDecalOnPagesLocal(targetMesh, SIGN = 1) {
  // Ensure we have a Mesh with geometry
  const mesh = targetMesh.isMesh ? targetMesh : null;
  if (!mesh || !mesh.geometry) return null;

  // Make sure local bounding box exists
  if (!mesh.geometry.boundingBox) mesh.geometry.computeBoundingBox();
  const bb = mesh.geometry.boundingBox; // local-space Box3
  const centerLocal = bb.getCenter(new THREE.Vector3());
  const sizeLocal   = bb.getSize(new THREE.Vector3());
  const halfLocal   = sizeLocal.clone().multiplyScalar(0.5);

  // Point at center of +X face in local space
  const pointLocal = new THREE.Vector3(centerLocal.x + SIGN * halfLocal.x, centerLocal.y, centerLocal.z);

  // Convert that point to world space
  const pointWorld = pointLocal.clone().applyMatrix4(mesh.matrixWorld);

  // Local +X normal -> world space normal
  const normalLocal = new THREE.Vector3(SIGN, 0, 0);
  const normalWorld = normalLocal.clone().transformDirection(mesh.matrixWorld).normalize();

  // Outward nudge relative to projector depth; keep center within the box
  const projectorDepth = Math.max(halfLocal.x * 0.12, 0.001);
  const outward = projectorDepth * 0.25;
  const decalPos = pointWorld.clone().add(normalWorld.clone().multiplyScalar(outward));

  // Orientation: make decal's +Z face along the outward normal
  const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), normalWorld);
  const euler = new THREE.Euler().setFromQuaternion(quat, "XYZ");

  // Decal size: span some of local Y/Z, shallow depth along X
  const sizeVec = new THREE.Vector3(
    Math.max(halfLocal.y * 0.6, 0.001),
    Math.max(halfLocal.z * 0.6, 0.001),
    projectorDepth
  );

  return { decalPos, euler, sizeVec };
}


// === Find the likely "pages" mesh by geometry heuristics ===
// We assume the "open" side is +X in model space for now; we auto-detect if it's -X.
// Strategy:
//  - Compute overall bbox of root
//  - Among meshes whose +X *or* -X face is notably inset from the overall extreme (~2%),
//    choose the one with the largest Y*Z face area (flat page block).
function findPagesMesh(root){
  const meshes = [];
  root.traverse(o => { if (o.isMesh) meshes.push(o); });
  if (meshes.length === 0) return { mesh: null, sign: +1 };

  // Overall bounds
  const overall = new THREE.Box3().setFromObject(root);
  const overallSize = overall.getSize(new THREE.Vector3());
  const overallW = overallSize.x;
  const insetMargin = Math.max( overallW * 0.02, 1e-3 ); // 2% or small epsilon

  // Collect candidates for +X and -X
  const candidates = [];
  for (const m of meshes){
    const bb = new THREE.Box3().setFromObject(m);
    const size = bb.getSize(new THREE.Vector3());
    const faceAreaYZ = Math.max(size.y * size.z, 0.0);

    const insetPlus  = (overall.max.x - bb.max.x) >= insetMargin;
    const insetMinus = (bb.min.x - overall.min.x) >= insetMargin;

    if (insetPlus || insetMinus){
      candidates.push({
        mesh: m,
        faceAreaYZ,
        sign: insetPlus ? +1 : -1,
        inset: insetPlus ? (overall.max.x - bb.max.x) : (bb.min.x - overall.min.x)
      });
    }
  }

  if (candidates.length === 0){
    // fallback: choose mesh with largest YZ face area; guess +X
    let best = null;
    for (const m of meshes){
      const bb = new THREE.Box3().setFromObject(m);
      const size = bb.getSize(new THREE.Vector3());
      const faceAreaYZ = Math.max(size.y * size.z, 0.0);
      if (!best || faceAreaYZ > best.faceAreaYZ){
        best = { mesh: m, sign: +1, faceAreaYZ };
      }
    }
    return best || { mesh: null, sign: +1 };
  }

  // Prefer the candidate with the largest YZ area; tie-break by larger inset
  candidates.sort((a,b)=> (b.faceAreaYZ - a.faceAreaYZ) || (b.inset - a.inset));
  return { mesh: candidates[0].mesh, sign: candidates[0].sign };
}


// === Place on the selected mesh's Â±X face with a small inward bias so it sits on pages ===
function placeOnMeshFaceX_Inward(mesh, SIGN){
  if (!mesh || !mesh.geometry) {
    return null;
  }
  if (!mesh.geometry.boundingBox) mesh.geometry.computeBoundingBox();
  const bbLocal = mesh.geometry.boundingBox; // LOCAL
  const centerL = bbLocal.getCenter(new THREE.Vector3());
  const sizeL   = bbLocal.getSize(new THREE.Vector3());
  const halfL   = sizeL.clone().multiplyScalar(0.5);

  // Center of Â±X face in LOCAL coords
  const xFaceLocal = new THREE.Vector3(centerL.x + SIGN * halfL.x, centerL.y, centerL.z);

  // Slight inward shift (toward interior) to avoid catching cover lips
  const inward = Math.max(halfL.x * 0.06, 0.001); // 6% of half thickness
  xFaceLocal.x -= SIGN * inward;

  // To WORLD
  const xFaceWorld = xFaceLocal.clone().applyMatrix4(mesh.matrixWorld);

  // Normal: Â±X in LOCAL -> WORLD
  const normalLocal = new THREE.Vector3(SIGN, 0, 0);
  const normalWorld = normalLocal.clone().transformDirection(mesh.matrixWorld).normalize();

  // Projector depth & small outward offset (keep decal volume intersecting surface)
  const projectorDepth = Math.max(halfL.x * 0.18, 0.002);
  const outward = projectorDepth * 0.22;
  const pos = xFaceWorld.clone().add(normalWorld.clone().multiplyScalar(outward));

  // Orientation: decal +Z along outward normal; +Y remain vertical-ish
  const worldUp = new THREE.Vector3(0,1,0);
  let yAxis = worldUp.clone().sub(normalWorld.clone().multiplyScalar(worldUp.dot(normalWorld)));
  if (yAxis.lengthSq() < 1e-6) yAxis = new THREE.Vector3(1,0,0);
  yAxis.normalize();
  const xAxis = new THREE.Vector3().crossVectors(yAxis, normalWorld).normalize();
  const rot = new THREE.Matrix4().makeBasis(xAxis, yAxis, normalWorld);
  const euler = new THREE.Euler().setFromRotationMatrix(rot, "XYZ");

  // Size: span a healthy chunk of the page height/width
  const sizeVec = new THREE.Vector3(
    Math.max(halfL.z * 0.46, 0.001), // width (thin)
    Math.max(halfL.y * 0.70, 0.001), // height (tall)
    projectorDepth
  );

  return { pos, euler, sizeVec };
}





function createButtonTexture(){
  const W = 256, H = 512;
  const c = document.createElement('canvas'); c.width=W; c.height=H;
  const ctx = c.getContext('2d');
  ctx.clearRect(0,0,W,H);

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y,   x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x,   y+h, rr);
    ctx.arcTo(x,   y+h, x,   y,   rr);
    ctx.arcTo(x,   y,   x+w, y,   rr);
    ctx.closePath();
  }

  const pad = Math.round(W * 0.18);
  const topPad = Math.round(H * 0.16);
  const botPad = Math.round(H * 0.16);
  const rectW = W - pad*2, rectH = H - topPad - botPad;
  ctx.fillStyle = 'rgba(255,255,255,0.40)';
  roundRect(pad, topPad, rectW, rectH, Math.min(18, W*0.07));
  ctx.fill();

  ctx.save();
  ctx.shadowColor = 'rgba(255,255,255,0.95)';
  ctx.shadowBlur = Math.max(W, H) * 0.12;
  ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
  ctx.fillStyle = 'rgba(255,255,255,0.40)';
  const inset = Math.round(W * 0.22);
  roundRect(pad + inset*0.35, topPad + inset*0.45, rectW - inset*0.70, rectH - inset*0.80, Math.min(14, W*0.06));
  ctx.fill();
  ctx.restore();

  const edgeFade = ctx.createLinearGradient(pad,0,pad+rectW,0);
  edgeFade.addColorStop(0.0, 'rgba(255,255,255,0.0)');
  edgeFade.addColorStop(0.08,'rgba(255,255,255,0.08)');
  edgeFade.addColorStop(0.92,'rgba(255,255,255,0.08)');
  edgeFade.addColorStop(1.0, 'rgba(255,255,255,0.0)');
  ctx.fillStyle = edgeFade;
  roundRect(pad, topPad, rectW, rectH, Math.min(18, W*0.07));
  ctx.fill();

  const tex = new THREE.CanvasTexture(c);
  tex.encoding = THREE.sRGBEncoding;
  tex.needsUpdate = true;
  tex.wrapS = THREE.ClampToEdgeWrapping;
  tex.wrapT = THREE.ClampToEdgeWrapping;
  return tex;
}
// Projects a decal on the first mesh in the loaded GLB and parents it to modelRoot
	  
// === UPDATED: Place Decal on the Center Face (Z-Axis) ===
// This works for the coin/cylinder by targeting the flat face instead of the rim
function placeDecalOnFaceZ(mesh, aspectRatio = 1) {
  if (!mesh || !mesh.geometry) return null;

  // 1. Compute World Bounding Box
  // We uses world bounds to ensure we find the true "front" regardless of rotation
  if (!mesh.geometry.boundingBox) mesh.geometry.computeBoundingBox();
  const box = new THREE.Box3().setFromObject(mesh);
  const size = new THREE.Vector3();
  box.getSize(size);
  const center = new THREE.Vector3();
  box.getCenter(center);

  // 2. Identify the Z-Face (Front)
  // We place the decal slightly in front of the object's max Z extent
  const faceZ = box.max.z; 
  const pos = new THREE.Vector3(center.x, center.y, faceZ + 0.01); // 0.01 offset to prevent flickering

  // 3. Orientation (Facing +Z)
  // Decals project along their local Z-axis. By setting rotation to (0,0,0), 
  // we align it with the world Z-axis, pointing "out" towards the camera.
  const euler = new THREE.Euler(0, 0, 0);

  // 4. Size
  // We base the size on the generic radius of the object (X or Y width)
  // The scale factor (0.4) determines how big the button is relative to the coin
  const radius = Math.min(size.x, size.y) * 0.4; 
  
  const sizeVec = new THREE.Vector3(
    radius * aspectRatio,  // Width
    radius,                // Height
    0.5                    // Depth (how deep it projects into the mesh)
  );

  return { pos, euler, sizeVec };
}

// REPLACE 'addHotButtonDecal' WITH THIS:

function addHotButtonSticker(root) {
  // 1. Clean up old objects if they exist
  const existing = modelRoot.getObjectByName('hotButtonSticker');
  if (existing) {
    if(existing.geometry) existing.geometry.dispose();
    if(existing.material) existing.material.dispose(); 
    modelRoot.remove(existing); 
  }

  // 2. Find the Coin Mesh to get its size
  let target = null;
  root.traverse(o => { if (!target && o.isMesh) target = o; });
  if (!target) return;

  // 3. Measure the Coin
  if (!target.geometry.boundingBox) target.geometry.computeBoundingBox();
  const box = new THREE.Box3().setFromObject(target);
  const size = new THREE.Vector3(); 
  box.getSize(size);
  
  // Calculate size (approx 50% of the coin's width)
  const buttonSize = Math.min(size.x, size.y) * 0.5; 

  // 4. Load the Image
  textureLoader.load('decal.png', (tex) => {
    tex.colorSpace = THREE.SRGBColorSpace;
    
    // === FIX 3 & BONUS: Re-assign to global hotButtonMat so it flashes ===
    hotButtonMat = new THREE.MeshBasicMaterial({
      map: tex,
      transparent: true,
      color: 0xffffff,
      
      // === FIX 2: Visibility Issues ===
      // "depthTest: true" ensures the coin blocks the text when looked at from behind.
      // "FrontSide" ensures the sticker itself is invisible if you look at its back.
      depthWrite: false, 
      depthTest: true,  
      side: THREE.FrontSide 
    });

    // 5. Create the "Sticker" Plane
    const aspect = tex.image.width / tex.image.height;
    const geometry = new THREE.PlaneGeometry(buttonSize * aspect, buttonSize);
    
    const sticker = new THREE.Mesh(geometry, hotButtonMat);
    sticker.name = 'hotButtonSticker';
    sticker.renderOrder = 9999; 

    // === FIX 1: Rotation ===
    // Rotate 90 degrees Counter-Clockwise (PI/2)
    sticker.rotation.z = Math.PI / 2;

    // === FIX 3: Clickability ===
    // We must assign this new mesh to the global 'hotButton' variable 
    // so the existing event listeners can find it.
    hotButton = sticker;

    // 6. Position it
    // Calculate the front face Z position
    const zOffset = (box.max.z - box.min.z) / 2; 
    
    // Move it to the front face + a small gap (0.05) to prevent flickering (z-fighting)
    sticker.position.set(0, 0, zOffset + 0.05); 
    
    modelRoot.add(sticker);
  });
}


// === Place on the selected mesh's Â±X face with a small inward bias so it sits on pages ===
function placeOnMeshFaceX_Inward(mesh, SIGN, aspectRatio = 1) {
  if (!mesh || !mesh.geometry) {
    return null;
  }
  if (!mesh.geometry.boundingBox) mesh.geometry.computeBoundingBox();
  const bbLocal = mesh.geometry.boundingBox; // LOCAL
  const centerL = bbLocal.getCenter(new THREE.Vector3());
  const sizeL = bbLocal.getSize(new THREE.Vector3());
  const halfL = sizeL.clone().multiplyScalar(0.5);

  // Center of Â±X face in LOCAL coords
  const xFaceLocal = new THREE.Vector3(centerL.x + SIGN * halfL.x, centerL.y, centerL.z);

  // Slight inward shift (toward interior) to avoid catching cover lips
  const inward = Math.max(halfL.x * 0.06, 0.001); // 6% of half thickness
  xFaceLocal.x -= SIGN * inward;

  // To WORLD
  const xFaceWorld = xFaceLocal.clone().applyMatrix4(mesh.matrixWorld);

  // Normal: Â±X in LOCAL -> WORLD
  const normalLocal = new THREE.Vector3(SIGN, 0, 0);
  const normalWorld = normalLocal.clone().transformDirection(mesh.matrixWorld).normalize();

  // Projector depth & small outward offset (keep decal volume intersecting surface)
  const projectorDepth = Math.max(halfL.x * 0.18, 0.002);
  const outward = projectorDepth * 0.22;
  const pos = xFaceWorld.clone().add(normalWorld.clone().multiplyScalar(outward));

  // Orientation: decal +Z along outward normal; +Y remain vertical-ish
  const worldUp = new THREE.Vector3(0, 1, 0);
  let yAxis = worldUp.clone().sub(normalWorld.clone().multiplyScalar(worldUp.dot(normalWorld)));
  if (yAxis.lengthSq() < 1e-6) yAxis = new THREE.Vector3(1, 0, 0);
  yAxis.normalize();
  const xAxis = new THREE.Vector3().crossVectors(yAxis, normalWorld).normalize();
  const rot = new THREE.Matrix4().makeBasis(xAxis, yAxis, normalWorld);
  const euler = new THREE.Euler().setFromRotationMatrix(rot, "XYZ");

  // *** FIX STARTS HERE ***
  // Size: span a healthy chunk of the page height/width, but preserve aspect ratio
  const height = Math.max(halfL.y * 0.70, 0.001);
  const width = height * aspectRatio;
  const sizeVec = new THREE.Vector3(
    width, // width
    height, // height
    projectorDepth
  );
  // *** FIX ENDS HERE ***

  return {
    pos,
    euler,
    sizeVec
  };
}



	  function setupPostProcessing(){
		// BLOOM / GOD RAYS / FLARE for BLOOM layer only
		bloomComposer = new THREE.EffectComposer(renderer);
		bloomComposer.renderToScreen = false;
		bloomComposer.addPass(new THREE.RenderPass(scene, camera));

		occlusionRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth/2, window.innerHeight/2);
		// Depth/occlusion mask for bloom (prevents bloom shining through solid geometry)
		depthMaskRT = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
		maskMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
		const godRaysShader = {
		  uniforms: { 'tDiffuse': { value: null }, 'tOcclusion': { value: null }, 'uLightPositionNDC': { value: new THREE.Vector2() }, 'uDensity': { value: 0.95 }, 'uDecay': { value: 0.98 }, 'uWeight': { value: 0.3 }, 'uExposure': { value: 0.6 } },
		  vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
		  fragmentShader: `uniform sampler2D tDiffuse; uniform sampler2D tOcclusion; uniform vec2 uLightPositionNDC; uniform float uDensity,uDecay,uWeight,uExposure; varying vec2 vUv; const int NUM_SAMPLES=100; void main(){ vec4 base=texture2D(tDiffuse,vUv); vec2 delta=(vUv - uLightPositionNDC)*(1.0/float(NUM_SAMPLES))*uDensity; float decay=1.0; vec4 acc=vec4(0.0); for(int i=0;i<NUM_SAMPLES;i++){ vec2 suv=vUv - delta*float(i);
			vec2 suvClamped = clamp(suv, vec2(0.0), vec2(1.0));
			float inb = step(0.0,suv.x)*step(suv.x,1.0)*step(0.0,suv.y)*step(suv.y,1.0);
			float occ=texture2D(tOcclusion,suvClamped).r * inb; acc += occ*decay*uWeight; decay *= uDecay; } gl_FragColor = base + acc*uExposure; }`
		};
		godRaysPass = new THREE.ShaderPass(godRaysShader);
		godRaysPass.uniforms.tOcclusion.value = occlusionRenderTarget.texture;
		bloomComposer.addPass(godRaysPass);

		bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.1, 0.28, 0.6);
		bloomComposer.addPass(bloomPass);

		const flareShader = {
		  uniforms: { 'tDiffuse': { value: null }, 'uLightPositionNDC': { value: new THREE.Vector3() }, 'uDirtTexture': { value: createProceduralDirtTexture() }, 'uStarburst': { value: 0.6 }, 'uLensDirt': { value: 0.65 }, 'uResolution': { value: new THREE.Vector2(window.innerWidth, window.innerHeight) } },
		  vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
		  fragmentShader: `uniform sampler2D tDiffuse,uDirtTexture; uniform vec3 uLightPositionNDC; uniform float uStarburst,uLensDirt; uniform vec2 uResolution; varying vec2 vUv; void main(){ vec4 base=texture2D(tDiffuse,vUv); vec2 scr=vUv*2.0-1.0; float aspect=uResolution.x/uResolution.y; scr.x*=aspect; vec2 lp=uLightPositionNDC.xy; lp.x*=aspect; vec2 L=lp-scr; float d=length(L); float vis=max(0.0,1.0-d*0.8);
			
			vec2 centered_uv = vUv - 0.5;
			if (aspect >= 1.0) {
				centered_uv.x *= aspect;
			} else {
				centered_uv.y /= aspect;
			}
			// Scale down to sample from the center of the larger texture (oversample)
			// A scale of 2.0 means we're using a texture 2x wider and 2x taller than needed.
			float oversampleScale = 2.0;
			centered_uv /= oversampleScale;
			vec2 dirtUv = centered_uv + 0.5;
			// No clamping needed, UVs will be within the [0,1] range of the oversized texture.
			vec3 dirt = texture2D(uDirtTexture, dirtUv).rgb * uLensDirt;

			float ang=atan(L.y,L.x); float star=0.0; if(uStarburst>0.0){ for(int i=0;i<8;i++){ float off=float(i)/8.0*6.2831853; vec2 dir=vec2(cos(ang+off),sin(ang+off)); for(int j=1;j<12;j++){ vec2 suv=vUv+vec2(dir.x/aspect,dir.y)*float(j)*0.005;
			vec2 suvClamped = clamp(suv, vec2(0.0), vec2(1.0));
			float inb2 = step(0.0,suv.x)*step(suv.x,1.0)*step(0.0,suv.y)*step(suv.y,1.0);
			float luma=dot(texture2D(tDiffuse,suvClamped).rgb, vec3(0.299,0.587,0.114));
			star += pow(luma,4.0)*(1.0-float(j)/12.0)*inb2; } } } vec3 starCol = vec3(0.8,0.8,1.0)*star*uStarburst*0.1; vec3 finalFlare = (starCol + dirt) * vis; gl_FragColor = base + vec4(finalFlare,1.0); }`
		};
		flarePass = new THREE.ShaderPass(flareShader); bloomComposer.addPass(flarePass);

		// FINAL composer: full scene + add bloom texture from bloomComposer
		finalComposer = new THREE.EffectComposer(renderer);
		const baseRenderPass = new THREE.RenderPass(scene, camera);
		finalComposer.addPass(baseRenderPass);
		finalPass = new THREE.ShaderPass(new THREE.ShaderMaterial({
		  uniforms: { baseTexture: { value: null }, bloomTexture: { value: null }, occludeTexture: { value: null } },
		  vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
		  fragmentShader: `uniform sampler2D baseTexture, bloomTexture, occludeTexture; varying vec2 vUv; void main(){ vec4 base=texture2D(baseTexture,vUv); float occ=texture2D(occludeTexture,vUv).r; // hard-gate bloom anywhere occluder is present
			float block = step(0.2, occ); // if mask >= 0.2, block completely
			vec4 bloom = texture2D(bloomTexture,vUv) * (1.0 - block);
			gl_FragColor = base + bloom; }`
		}), 'baseTexture');
		finalPass.uniforms.bloomTexture.value = bloomComposer.renderTarget2.texture;
		finalPass.uniforms.occludeTexture.value = depthMaskRT.texture;
		if (finalPass.uniforms.uResolution) finalPass.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
		finalComposer.addPass(finalPass);
		if ('renderToScreen' in finalPass) finalPass.renderToScreen = true;
	  }

	  function setSize(w, h){
		camera.aspect = w / h; camera.updateProjectionMatrix();
		renderer.setSize(w, h);
		if (bloomComposer) bloomComposer.setSize(w, h);
		if (finalComposer) finalComposer.setSize(w, h);
		if (occlusionRenderTarget) occlusionRenderTarget.setSize(w/2, h/2);
		if (depthMaskRT) depthMaskRT.setSize(w, h);
		if (flarePass) flarePass.uniforms.uResolution.value.set(w, h);
		if (finalPass && finalPass.uniforms.uResolution) finalPass.uniforms.uResolution.value.set(w, h);
		if (effectsPass && effectsPass.uniforms.uResolution) effectsPass.uniforms.uResolution.value.set(w, h);
	  }
	  setupPostProcessing();
	  setSize(window.innerWidth, window.innerHeight);
	  window.addEventListener('resize', () => setSize(window.innerWidth, window.innerHeight));

	  // --- Asset loading: load model.glb (embedded textures); fallback to checkerboard image ---
	  const gltfLoader = new THREE.GLTFLoader(loadingManager);
	 if (THREE.DRACOLoader) {
		const draco = new THREE.DRACOLoader();
		draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.4.3/');
		gltfLoader.setDRACOLoader(draco);
	  }
	  const textureLoader = new THREE.TextureLoader(loadingManager);
	  // const MODEL_URL = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb';
	   const MODEL_URL = '/model.glb';

	  function setZoomLimits(dist, radius){
		// Min: allow close approach but stop at ~2.0Ã— bounding radius
		const safeMin = Math.max((radius || 0.5) * 2.0, 0.2);
		controls.minDistance = safeMin;
		// Max: reduce previous cap by ~10%
		const prevMax = Math.min(camera.far * 0.98, 5000);
		controls.maxDistance = prevMax * 0.8;
	  }

	  function frameObject(obj){
		const box = new THREE.Box3().setFromObject(obj);
		const size = new THREE.Vector3(); box.getSize(size);
		const center = new THREE.Vector3(); box.getCenter(center);
		const maxSize = Math.max(size.x, size.y, size.z, 0.001);
		const sphere = new THREE.Sphere(); box.getBoundingSphere(sphere); lastBoundRadius = sphere.radius;
		const fitHeightDistance = maxSize / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)));
		const fitWidthDistance = fitHeightDistance / (window.innerHeight / window.innerWidth);
		const distance = Math.max(fitHeightDistance, fitWidthDistance) * 1.2;
		camera.position.copy(center).add(new THREE.Vector3(0, 0, distance));
		controls.target.copy(center);
		setZoomLimits(distance, sphere.radius);
		controls.update();
	  }

	  function placeModel(gltf){
		const root = gltf.scene || gltf.scenes?.[0];
		if (!root){ console.warn('GLB had no scene'); loaderEl.textContent='Could not read model.glb'; return; }
		// Make the model fully opaque and ensure correct depth
		root.traverse(obj=>{
		  if (obj.isMesh){
			obj.layers.disable(1); // keep off bloom layer
			const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
			mats.forEach(m=>{
			  if (!m) return;
			  m.transparent = false;
			  m.opacity = 1.0;
			  m.depthWrite = true;
			  m.depthTest = true;
			  m.side = THREE.FrontSide;
			  m.blending = THREE.NormalBlending;
			  if ('alphaMap' in m) m.alphaMap = null;
			  if ('transmission' in m) m.transmission = 0.0;
			  if ('alphaTest' in m) m.alphaTest = 0.0;
			  // Gentle self-light so back faces aren't too dark
			  if ('emissive' in m && m.emissive && m.emissive.setHex) { m.emissive.setHex(0xffffff); }
			  if ('emissiveIntensity' in m) { m.emissiveIntensity = 0.1; }
			  m.needsUpdate = true;
			});
		  }
		});
		scene.add(root);
		modelRoot = root;
		frameObject(root);
		addHotButtonSticker(root);
		loaderEl.style.display = 'none';
	  }

	  function placePhotoTexture(tex){
		const aspect = tex.image.width / tex.image.height || 1;
		const planeW = 6, planeH = planeW / aspect;
		const geom = new THREE.PlaneGeometry(planeW, planeH);
		const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
		const mesh = new THREE.Mesh(geom, mat);
		mesh.name = 'photoPlane';
		mesh.position.set(0, 0, 0);
		scene.add(mesh);
		mesh.layers.disable(1);
		photoRoot = mesh;
		frameObject(mesh);
		loaderEl.style.display = 'none';
	  }

	  function generateFallbackTexture(){
		const size = 1024;
		const c = document.createElement('canvas'); c.width = c.height = size;
		const ctx = c.getContext('2d');
		for (let y = 0; y < 8; y++) {
		  for (let x = 0; x < 8; x++) {
			ctx.fillStyle = ((x + y) % 2) ? '#3a3a3a' : '#6a6a6a';
			ctx.fillRect(x * size / 8, y * size / 8, size / 8, size / 8);
		  }
		}
		ctx.fillStyle = '#ffffff'; ctx.font = 'bold 160px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
		ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('MODEL MISSING', size/2, size/2);
		const tex = new THREE.CanvasTexture(c); tex.encoding = THREE.sRGBEncoding; tex.needsUpdate = true; return tex;
	  }

	  function boot(){
		gltfLoader.load(
		  MODEL_URL,
		  (gltf)=> placeModel(gltf),
		  undefined,
		  (err)=>{
			console.warn('model.glb not found; showing fallback image', err);
			const tex = generateFallbackTexture();
			placePhotoTexture(tex);
		  }
		);
	  }

	  boot();
	  
	  /* CLICK listener (arrow) removed by patch (press+release required)
canvas.addEventListener('click', (ev) => {
		if (!hotButton) return;
		const rect = renderer.domElement.getBoundingClientRect();
		pointer.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
		pointer.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
		raycaster.setFromCamera(pointer, camera);
		const hits = raycaster.intersectObject(hotButton, true);
		if (hits.length) {
		  ev.stopPropagation();
		  // ðŸ‘‰ Replace this with your real action:
		  
		}
	  });
*/


	  // --- Animation ---
	  const screenPos = new THREE.Vector3();
	  (function animate(){
		requestAnimationFrame(animate);
		controls.update();

		// Self rotation for model and photo/fallback
		if (modelRoot) modelRoot.rotation.y += ROT_SPEED;
		if (photoRoot) photoRoot.rotation.y += ROT_SPEED;
		
		// Flashing (opacity pulse)
        if (hotButtonMat) {
          /* brightness: sinusoidal (raised cosine), ~1.05s per cycle */
          { const t = performance.now() / 1000; const period = 1.05; const phase = (t % period) / period;
            const min = 0.05, max = 0.20;
            hotButtonMat.opacity = min + (max - min) * 0.5 * (1 - Math.cos(2*Math.PI*phase)); }
          /* hue: sinusoidal full sweep 0â†’1â†’0 over 10s */
          { const t = performance.now() / 1000; const period = 10.0; const phase = (t % period) / period;
            const h = 0.5 * (1 - Math.cos(2*Math.PI*phase)); if (hotButtonMat.color && hotButtonMat.color.setHSL)
              hotButtonMat.color.setHSL(h, 0.95, 0.60); }
        }




		if (flareLight) {
		  flareLight.getWorldPosition(screenPos);
		  screenPos.project(camera);
		  if (flarePass)   flarePass.uniforms.uLightPositionNDC.value.copy(screenPos);
		  if (effectsPass) effectsPass.uniforms.uLightPositionNDC.value.copy(screenPos);
		  if (godRaysPass) godRaysPass.uniforms.uLightPositionNDC.value.set(screenPos.x*0.5+0.5, screenPos.y*0.5+0.5);
		}

		if (godRaysPass) {
		  // Occlusion: blockers as black, then ONLY the flare sprite (hide starfield & other bloom items)
		  const currentTarget = renderer.getRenderTarget();
		  const prevMask = camera.layers.mask;
		  const prevOverride = scene.overrideMaterial;

		  renderer.setRenderTarget(occlusionRenderTarget);
		  renderer.setClearColor(0x000000, 1);
		  renderer.clear(true, true, true);

		  // Pass 1: blockers populate depth as solid black
		  scene.overrideMaterial = darkMaterial;
		  camera.layers.set(BASE_LAYER);
		  renderer.render(scene, camera);

		  // Pass 2: flare sprite + a sparse, dim set of "guide stars" for subtle streaks
		  scene.overrideMaterial = null;
		  const flareStar = scene.getObjectByName('flareStar');
		  const starfield = scene.getObjectByName('starfield');
		  const hidden = [];
		  scene.traverse(o => {
			if (o === starfield || o === flareStar) return; // keep starfield + flare
			if (o.isPoints || o.isMesh || o.isSprite) {
			  hidden.push(o); o.visible = false;
			}
		  });

		  // Prepare a very dim material & draw only a small subset of points
		  let originalStarMat = null, originalRange = null, starCount = 0;
		  if (starfield) {
			originalStarMat = starfield.material;
			if (!starOccMat) {
			  starOccMat = new THREE.PointsMaterial({ color: 0xffffff, size: originalStarMat.size || 0.7, sizeAttenuation: true, map: (starSpriteTex || (starSpriteTex = createStarSpriteTexture())), transparent: true, opacity: 0.06, alphaTest: 0.1, depthWrite: false });
			}
			starfield.material = starOccMat;
			const attr = starfield.geometry.getAttribute('position');
			starCount = attr ? attr.count : 0;
			originalRange = { start: starfield.geometry.drawRange.start || 0, count: starfield.geometry.drawRange.count || starCount };
			const subset = Math.min(400, starCount); // a few hundred brightest-looking stars (proxy)
			starfield.geometry.setDrawRange(0, subset);
		  }

		  camera.layers.set(BLOOM_LAYER);
		  renderer.render(scene, camera);

		  // restore starfield and visibility
		  if (starfield) {
			if (originalRange) starfield.geometry.setDrawRange(originalRange.start, originalRange.count);
			if (originalStarMat) starfield.material = originalStarMat;
		  }
		  for (const o of hidden) o.visible = true;
		  for (const o of hidden) o.visible = true;

		  // Restore state
		  camera.layers.mask = prevMask;
		  scene.overrideMaterial = prevOverride;
		  renderer.setRenderTarget(currentTarget);
		}

		// Build occlusion mask so bloom doesn't show through solid geometry
		{
		  const currentTarget2 = renderer.getRenderTarget();
		  const prevMask2 = camera.layers.mask;
		  const prevOverride2 = scene.overrideMaterial;
		  const flareStar2 = scene.getObjectByName('flareStar');
		  const starfield2 = scene.getObjectByName('starfield');
		  const hidden2 = [];
		  if (flareStar2) { hidden2.push(flareStar2); flareStar2.visible = false; }
		  if (starfield2) { hidden2.push(starfield2); starfield2.visible = false; }
		  renderer.setRenderTarget(depthMaskRT);
		  renderer.setClearColor(0x000000, 1);
		  renderer.clear(true, true, true);
		  scene.overrideMaterial = maskMaterial;
		  camera.layers.set(BASE_LAYER);
		  renderer.render(scene, camera);
		  camera.layers.mask = prevMask2;
		  scene.overrideMaterial = prevOverride2;
		  renderer.setRenderTarget(currentTarget2);
		  for (const o of hidden2) o.visible = true;
		}
		renderer.clear();
		// Selective bloom: render BLOOM layer with others darkened, then full scene + add bloom
		camera.layers.set(BLOOM_LAYER);
		scene.traverse(darkenNonBloomed);
		bloomComposer.render();
		scene.traverse(restoreMaterial);
		camera.layers.set(BASE_LAYER);
		finalComposer.render();
	  })();
	};
  </script>
</body>
</html>
